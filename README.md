# Тестовое задание


Файл парсит лог построчно и составляет интервалы, где доля аптайма была меньше заданного значения.

Логика такая:
Сначала построчно парсится лог.
Если запрос вернул '5**' или выполнялся дольше заданного времени он помешается в массив плохих запросов $badRequests. В этом массиве у нас есть полный список плохих запросов. 
<p>Далее составляем временные интервалы следующим образом:</p>
<ul>
<li>1й интервал : между временем 1-го и 2-го плохого запроса</li>
<li>2й интервал : между временем 1-го и 3-го плохого запроса</li>
<li>3й интервал : между временем 1-го и 4-го плохого запроса</li>
...
<li>n интервал : между временем 1-го и последнего плохого запроса</li>
<li>n+1 интервал: между временем 2-го и 3-го плохого запроса</li>
<li>n+2 интервал: между временем 2-го и 4-го плохого запроса</li>
<li>n+l интервал : между временем 2-го и последнего плохого запроса</li>
...

<li>и так далее до того как мы дойдем до интервала между предпоследним и последним плохим запросом.</li>
  </ul>
Таким образом мы охватим все временные интервалы, в которых был хотя бы один плохой запрос.

Скрипт выводит только время интервалов, но не дату, т.к. я допустил, что лог чистится каждые сутки.


<h2>Экономия оперативной памяти</h2>

Для экономии памяти при парсинге файла и переборе интервалов используются генераторы. Так, при обработке файла размером 70мб (300 000 строк) пиковое использование памяти составляет всего порядка 20 мб.

Тестовый файл лога прилагается.

<h2>Запуск</h2>

cat access.log | php analyze -u 95 -t 45
