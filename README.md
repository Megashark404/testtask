# testtask


Файл парсит лог построчно и составляет интервалы, где доля аптайма была меньше заданного значения.

Логика такая:
Сначала построчно парсится лог.
Если запрос вернул '5**' или выполнялся дольше заданного времени он помешается в массив плохих запросов $badRequests

В этом массиве у нас есть полный список плохих запросов. Далее составляем временные интервалы следующим образом:

1й интервал : между временем 1-го и 2-го плохого запроса
2й интервал : между временем 1-го и 3-го плохого запроса
3й интервал : между временем 1-го и 4-го плохого запроса
...
n интервал : между временем 1-го и последнего плохого запроса
n+1 интервал: между временем 2-го и 3-го плохого запроса
n+2 интервал: между временем 2-го и 4-го плохого запроса
n+l интервал : между временем 2-го и последнего плохого запроса
...
и так далее до того как мы дойдем до интервала между предпоследним и последним плохим запросом.

Таким образом мы охватим все временные интервалы, в которых был хотя бы один плохой запрос. Скрипт выводит только время интервалов, но не дату, т.к. я допустил, что лог чистится каждые сутки.






Для экономии памяти для парсинга файла и перебора интервалов используются генераторы. Так, при обработке файла размером 70мб (300 000 строк) пиковое использование памяти составляет всего порядка 20 мб.

Тестовый файл лога прилагается.

<h2>запуск</h2>

cat access.log | php analyze -u 95 -t 45
